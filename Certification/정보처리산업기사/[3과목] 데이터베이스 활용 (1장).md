# 3과목 데이터베이스 활용

## 1장 데이터베이스 이해

### 074 자료 구조

1. 자료 구조의 분류

    - 선형 구조 : 배열(Array), 선형 리스트(Linear List), 스택(Stack), 큐(Queue), 데크(Deque)
    
    - 비선형 구조 : 트리(Tree), 그래프(Graph)

2. 연결 리스트(Linked List)

    - 노드의 삽입 - 삭제 작업이 용이하다.
  
    - 연결을 위한 링크(포인터) 부분이 필요하다.
  
    - 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
  
    - 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

3. 스택(Stack)

    - 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
  
    - 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO) 방식으로 자료를 처리한다.
  
    - 스택을 이용한 연산은 '재귀 호출, 후위(Postfix) 표기법, 깊이 우선 탐색'과 같이 왔던 길을 되돌아가는 경우에 사용한다.

4. 스택의 응용 분야

    - 함수 호출의 순서 제어
  
    - 인터럽트의 처리
  
    - 수식 계산 및 수식 표기법
  
    - 컴파일러를 이용한 언어 번역
  
    - 부 프로그램 호출 시 복귀 주소 저장
  
    - 서브루틴 호출 및 복귀 주소 저장

5. 스택의 삽입(Push)과 삭제(Pop)

    - PUSH는 스택에 자료를 입력하는 명령이고, POP은 스택에서 자료를 출력하는 명령이다.

6. 큐(Queue)

    - 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조이다.
  
    - 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO) 방식으로 처리한다.

7. 데크(Deque)

    - 삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료 구조이다.
  
    - 입력이 한쪽에서만 발생하고 출력은 양쪽에서 일어날 수 있는 입력 제한과, 입력은 양쪽에서 일어나고 출력은 한 곳에서만 이루어지는 출력 제한이 있다.

8. 방향/무방향 그래프의 최대 간선 수

    - n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1) / 2 이고, 방향 그래프에서 최대 간선 수는 n(n-1)이다.
  
### 075 트리(Tree)

1. 트리의 개요

    트리는 정점(Node)과 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.

    ![Tree.jpg](https://velog.velcdn.com/images%2Fkji990607%2Fpost%2Faef2a86a-ddae-4322-b836-8f4ed4509359%2Fimage.png)
    
    - 노드(Node) : 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것
        - (예) A, B, C, D, E, F, G, H, K, L, M
    
    - 디그리(Degree, 차수) : 각 노드에서 뻗어나온 가지의 수
        - (예) A = 3, B = 2, C = 1, D = 3
    
    - 단말 노드(Terminal Node) : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
        - (예) K, L, F, G, M, I, J

2. 트리의 운행법

    ![Tree.jpg](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99796D485B66DDF317)

    - Preorder 운행법의 방문 순서
        - Preorder는 Root -> Left -> Right이므로 A13이 된다.
        - 1은 B2E이므로 AB2E3이 된다.
        - 2는 DHI이므로 ABDHIE3 된다.
        - 3은 CFG이므로 ABDHIECFG가 된다.
    
    - Inorder 운행법의 방문 순서
        - Inorder는 Left -> Root -> Right이므로 A13이 된다.
        - 1은 2BE이므로 2BEA3이 된다.
        - 2는 DHI이므로 DHIBEA3 된다.
        - 3은 FCG이므로 DHIBEAFCG 된다.
    
    - Postorder 방문 순서
        - Postorder는 Left -> Right -> Root이므로 A13이 된다.
        - 1은 2EB이므로 2EB3A이 된다.
        - 2는 HID이므로 HIDEB3A 된다.
        - 3은 FGC이므로 HIDEBFGCA 된다.

3. 수식의 표기법(Infix -> Postfix)

    - Infix로 표기된 수식에서 연산자를 해당 피연산자 두 개의 뒤(오른쪽)에 오도록 이동하면 Postfix가 된다.
  
    - X = A / B * (C + D) + E -> X A B / CD + * E + =

4. 수식의 표기법(Infix -> Prefix)

    - Infix로 표기된 수식에서 연산자를 해당 피연산자 두 개의 앞(왼쪽)에 오도록 이동하면 Prefix가 된다.
  
    - X = A / B * (C + D) + E -> X + * / A B + C D E

5. 수식의 표기법(Postfix -> Infix)

    - Postfix는 Infix 표기법에서 연산자를 해당 피연산자 2개의 뒤(오른쪽)로 이동한 것이므로 연산자를 다시 해당 피연산자 2개의 가운데로 옮기면 된다.
  
    - X = A / B * (C + D) + E -> A / (B - C) + D * (E + F)

### 076 정렬(Sort)

1. 삽입 정렬(Insertion Sort)

    예) 8, 5, 6, 2, 4 를 삽입 정렬하시오.

    - 초기 상태 : 8 5 6 2 4
  
    - 1회전 : 8 5 6 2 4 -> 5 8 6 2 4
  
    - 2회전 : 5 8 6 2 4 -> 5 6 8 2 4
  
    - 3회전 : 5 6 8 2 4 -> 2 5 6 8 4
  
    - 4회전 : 2 5 6 8 4 -> 2 4 5 6 8

2. 선택 정렬(Selection Sort)

    n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬한다.

    예) 8, 5, 6, 2, 4 를 선택 정렬하시오.

    - 초기 상태 : 8 5 6 2 4
  
    - 1회전 : 5 8 6 2 4 -> 5 8 6 2 4 -> 2 8 6 5 4 -> 2 8 6 5 4
  
    - 2회전 : 2 6 8 5 4 -> 2 5 8 6 4 -> 2 4 8 6 5
  
    - 3회전 : 2 4 6 8 5 -> 2 4 5 8 6
  
    - 4회전 : 2 4 5 6 8


3. 버블 정렬(Bubble Sort)

    주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환한다.

    예) 8, 5, 6, 2, 4 를 선택 정렬하시오.

    - 초기 상태 : 8 5 6 2 4
  
    - 1회전 : 5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 -> 5 6 2 4 8
  
    - 2회전 : 5 6 2 4 8 -> 5 2 6 4 8 -> 5 2 4 6 8
  
    - 3회전 : 2 5 4 6 8 -> 2 4 5 6 8
  
    - 4회전 : 2 4 5 6 8
  
### 077 검색-이분 분색 / 해싱

1. 이분 검색(이진 검색)

    - 반드시 순서화(정렬)된 파일이어야 검색할 수 있다.
    
    - 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.
  
    - 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
  
    - 중간 레코드 번호(M) : F + L / 2
        > 단, F : 첫번째 레코드 번호, L : 마지막 레코드 번호)

2. 해시 테이블(Hash Table)

    - Collision(충돌 현상) : 서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상
  
    - Synonym : 충돌로 인해 같은 Home Address를 갖는 레코드들의 집합

3. 주요 해싱 함수

    - 제산법(Division) : 레코드 키(K)를 해시펴(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈 나머지를 홈 주소로 삼는 방식
  
    - 제곱법(Mid-Square) : 레코드 키 값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
  
    - 숫자 분석법(Digit Analysis) : 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식 

### 078 데이터베이스 개요

1. DBMS의 필수 기능

    - 정의 기능(Definition) : 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 주고에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
  
    - 조작 기능(Manipulation) : 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
  
    - 제어 기능(Control) : 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어하는 기능

2. 스키마(Schema)

    - 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 기술(Description)한 메타 데이터(Meta-Data)의 집합이다.
  
    - 외부 스키마 : 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
  
    - 개념 스키마 : 데이터베이스의 전체적인 논리적 구조로서, 개체 간의 관계와 제약 조건을 나타내고, 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의함
  
    - 내부 스키마 : 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄 

### 079 데이터베이스 설계

1. 데이터베이스 설계 순서

    - 요구 조건 분석 : 요구 조건 명세서 작성
    
    - 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
    
    - 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
    
    - 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
    
    - 구현 : 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

2. 개념적 설계(정보, 모델링, 개념화)

    - 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다.
  
    - 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행한다.
  
    - 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성한다.
  
    - DBMS에 독립적인 개념 스키마를 설계한다.

3. 논리적 설계

    - 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(Mapping)시키는 과정이다.
  
    - 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.
  
    - 트랜잭션의 인터페이스를 설계한다.

4. 물리적 설계

    - 논리적 설계 단계에서 논맂거 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.
  
    - 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일릐 저장 구조 및 액세스 경로를 결정한다.
  
    - 물리적 설계 단계에 꼭 포함되어야 할 것 : 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계 등
  
    - 물리적 설계 옵션 선택 시 고려 사항 : 응답시간, 저장 공간의 효율화, 트랜잭션 처리도

### 080 데이터 모델의 개념

1. 데이터 모델에 표시할 개념

    - 구조(Structure) : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현함
  
    - 연산(Operation) : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구임
  
    - 제약 조건(Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건임

2. 데이터 모델의 구성 요소 - 개체(Entity)

    - 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체이다.
  
    - 실세계에 독립적으로 존재하는 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성된다.

3. 데이터 모델의 구성 요소 - 관계(Relationship)

    - 개체 간의 관계 또는 속성 간의 관계이다.
    
    - 관계의 형태
  
        - 일 대 일 ( 1 : 1 ) : 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계
     
        - 일 대 다 ( 1 : N ) : 개체 집합 A의 각 원소는 개체 집합 B 각 원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계
     
        - 다 대 다 ( N : N ) : 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계

### 081 E-R(개체-관계) 모델

1. E-R 다이어그램

|기호 이름|의미|
|--|--|
|사각형|개체(Entity) 타입|
|마름모|관계(Relationship) 타입|
|타원|속성(Attribute)|
|이중 타원|다중값 속성(복합 속성)|
|선, 링크|개체 타입과 속성을 연결|

### 082 관계형 데이터 모델

1. 관계형 데이터 모델(Relational Data Model)의 개요

    - 2차원적인 표(Table)를 이용해서 데이터 상화 관계를 정의하는 DB구조를 말한다.

    - 가장 널리 사용되는 데이터 모델이다.
  
    - 관계형 모델의 대표적인 언어는 SQL이다.

### 083 관계형 데이터베이스의 구조

1. 릴레이션(Relation)

    - 데이터들을 표의 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.

2. 튜플(Tuple)

    - 릴레이션을 구성하는 각각의 행이다.
  
    - 튜플은 속성의 모임으로 구성된다.
  
    - 튜플의 수 = 카디널리티 = 기수 = 대응수

3. 속성

    - 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
  
    - 속성은 개체의 특성을 기술한다.
  
    - 속성의 수 = 디그리(Degree) = 차수

4. 도메인

    - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합이다.
    - 예) 성별 도메인은 '남'과 '여'임

5. 릴레이션의 특징

    - 한 릴레이션에 포함된 튜플들은 모두 상이하다.
  
    - 한 릴레이션에 포함된 튜플 사이에는 순서기 없다.
  
    - 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
  
    - 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
  
    - 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.
  
    - 속성은 더 이상 쪼갤 수 없는 원자값만을 저장한다.
    
### 084 관계형 데이터베이스의 제약 조건 - 키(Key)

1. 후보키(Candidate Key)

    - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합이다.
  
    - 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다.

2. 기본키(Primary Key)

    - 후보키 중에서 특별히 선정된 주키(Main Key)로 중복된 값을 가질 수 없다.
  
    - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.

3. 대체키(Alternate key)

    - 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미하며, 보조키라고도 한다.

4. 슈퍼키(Super Key)

    - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키이다.
  
    - 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못한다.

5. 외래키(Foreign Key)

    - 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미한다.
  
    - 한 릴레이션에 속산 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성A를 외래키라고 한다.

6. 널값(Null Value)

    - 데이터베이스에서 아직 알려지지 않거나 모르는 값으로서 '해당 없음'등의 이유로 정보 부재를 나타내기 위해 사용하는, 이론적으로 아무것도 없는 특수한 데이터를 말한다.

### 085 관계형 데이터베이스의 제약 조건 - 무결성

1. 개체 무결성(Entity Integrity, 실체 무결성)

    - 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복 값을 가질 수 없다는 규정이다.

2. 도메인 무결성(Domain Integrity, 영역 무결성)

    - 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정이다.

3. 참조 무결성(Referential Integrity)

    - 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정이다.

4. 사용자 정의 무결성(User-Defined Integrity)

    - 속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다는 규정이다.

### 086 관계대수 및 관계해석

1. 관계대수의 개요

    - 관계형 DB에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 언어이다.
  
    - 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션이고 결과도 릴레이션이다.
  
    - 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다. 

2. 순수 관계 연산자

    |연산자|설명|기호|
    |--|--|--|
    |Select|릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산|시그마(a)|
    |Project|주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산|파이(π)|
    |Join|공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산|▷◁|
    |Division|X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산|÷|
    
3. 일반 집합 연산자

    |연산자|카디널리티|기호|
    |--|--|--|
    |합집합(UNION)|카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않음|∪|
    |교집합(INTERSECTION)|카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않음|∩|
    |차집합(DIFFERENCE)|카디널리티는 릴레이션 R의 카디널리티보다 크지 않음|-|
    |교집합(CARTESIANPRODUCT)|디그리는 두 릴레이션의 디그리를 더한 것과 같고, 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같음|X|

4. 관계해석

    - 코드(E.F Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안했다.
  
    - 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다.
  
    - 기본적으로 관계해석과 관계대수는 관계 DB를 처리하는 기능과 능력면에서 동등하다.

### 087 정규화

1. 정규화의 개요

    - 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다.
  
    - 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정이라 할 수 있다.

2. 정규화의 목적

    - 어떠한 릴레이션이라도 DB 내에서 표현 가능하게 만든다.
  
    - 데이터 중복을 배제하여 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화가 가능하다.
  
    - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.

3. 정규화 과정

    - 비정규 릴레이션
  
    - 1NF : 도메인이 원자값
  
    - 2NF : 부분적 함수 종속 제거
  
    - 3NF : 이행적 함수 종속 제거
  
    - BCNF : 결정자이면서 후보키가 아닌 것 제거
  
    - 4NF : 다치 종속 제거
  
    - 5NF : 조인 종속성 이용

4. 이상(Anomaly)의 개념 및 종류

    - 정규화를 거치지 않으면 DB 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 발생하는 에기치 못한 곤란한 현상을 의미한다.
  
    - 삽입 이상 : 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상
    
    - 삭제 이상 : 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상
    
    - 갱신 이상 : 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

5. 함수적 종속(Fuctional Dependency)

    - 데이터들이 어떤 기준값에 의해 종속되는 것을 의미한다.

6. 이행적 종속(Transitive Dependency)관계

    - A -> B 이고 B -> C 일 때 A -> C 를 만족하는 관계를 의미한다.

### 088 반정규화(Denormalization)

1. 반정규화의 개념

    - 시스템의 성능 향상, 개발 및 운영의 평의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.

2. 중복 테이블 추가 방법

    - 집계 테이블의 추가
  
    - 진행 테이블의 추가
  
    - 특정 부분만을 포함하는 테이블의 추가

### 089 인덱스(Index)

1. 인덱스(Index)의 개요

    - 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조이다.
  
    - 데이터가 저장된 물리적 구조와 밀접한 관계가 있다.
  
    - 인덱스를 통해서 파일의 레코드에 대한 액세스를 빠르게 수행할 수 있다.
  
    - 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적이다.

2. 인덱스의 종류

    - 트리 기반 인덱스 : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것으로, 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용함
  
    - 비트맵 인덱스 : 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
  
    - 함수 기반 인덱스 : 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것으로, B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용함
  
    - 비트맵 조인 인덱스 : 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름
  
    - 도메인 인덱스 : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스라고도 함

### 090 뷰(View)

1. 뷰의 개요

    - 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
  
    - 기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야함 삽입, 삭제, 갱신 연산이 가능하다.
  
    - 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.
  
    - 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP문을 사용한다.

2. 뷰의 장-단점

    - 장점
        - 논리적 데이터 독립성을 제공함
        - 사용자의 데이터 관리를 간단하게 해줌
        - 접근 제어를 통한 자동 보안이 제공됨
    
    - 단점
        - 독립적인 인덱스를 가질 수 없음
        - 뷰의 정의를 변경할 수 없음
        - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름

### 091 시스템 카탈로그 / 트랜잭션

1. 시스템 카탈로그

    - 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 DB이다.
  
    - 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있다.
  
    - INSERT, DELETE, UPDATE문으로 갱신하는 것은 허용하지 않는다.

2. 트랜잭션의 특성

    - Atomicty(원자성) : 트랜잭션의 연산은 DB에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함
  
    - Consistency(일관성) : 트랜잭션이 그 실행을 성공적으로 완료하면 언제난 일관성 있는 DB 상태로 변환함
  
    - Isolation(독립성) : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음
  
    - Durability(영속성) : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함
