# 3과목 데이터베이스 활용

## 1장 데이터베이스 이해

### 074 자료 구조

1. 자료 구조의 분류

    - 선형 구조 : 배열(Array), 선형 리스트(Linear List), 스택(Stack), 큐(Queue), 데크(Deque)
    
    - 비선형 구조 : 트리(Tree), 그래프(Graph)

2. 연결 리스트(Linked List)

    - 노드의 삽입 - 삭제 작업이 용이하다.
  
    - 연결을 위한 링크(포인터) 부분이 필요하다.
  
    - 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
  
    - 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

3. 스택(Stack)

    - 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
  
    - 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO) 방식으로 자료를 처리한다.
  
    - 스택을 이용한 연산은 '재귀 호출, 후위(Postfix) 표기법, 깊이 우선 탐색'과 같이 왔던 길을 되돌아가는 경우에 사용한다.

4. 스택의 응용 분야

    - 함수 호출의 순서 제어
  
    - 인터럽트의 처리
  
    - 수식 계산 및 수식 표기법
  
    - 컴파일러를 이용한 언어 번역
  
    - 부 프로그램 호출 시 복귀 주소 저장
  
    - 서브루틴 호출 및 복귀 주소 저장

5. 스택의 삽입(Push)과 삭제(Pop)

    - PUSH는 스택에 자료를 입력하는 명령이고, POP은 스택에서 자료를 출력하는 명령이다.

6. 큐(Queue)

    - 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조이다.
  
    - 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO) 방식으로 처리한다.

7. 데크(Deque)

    - 삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료 구조이다.
  
    - 입력이 한쪽에서만 발생하고 출력은 양쪽에서 일어날 수 있는 입력 제한과, 입력은 양쪽에서 일어나고 출력은 한 곳에서만 이루어지는 출력 제한이 있다.

8. 방향/무방향 그래프의 최대 간선 수

    - n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1) / 2 이고, 방향 그래프에서 최대 간선 수는 n(n-1)이다.
  
### 075 트리(Tree)

1. 트리의 개요

    트리는 정점(Node)과 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.

    ![Tree.jpg](https://velog.velcdn.com/images%2Fkji990607%2Fpost%2Faef2a86a-ddae-4322-b836-8f4ed4509359%2Fimage.png)
    
    - 노드(Node) : 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것
        - (예) A, B, C, D, E, F, G, H, K, L, M
    
    - 디그리(Degree, 차수) : 각 노드에서 뻗어나온 가지의 수
        - (예) A = 3, B = 2, C = 1, D = 3
    
    - 단말 노드(Terminal Node) : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
        - (예) K, L, F, G, M, I, J

2. 트리의 운행법

    ![Tree.jpg](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99796D485B66DDF317)

    - Preorder 운행법의 방문 순서
        - Preorder는 Root -> Left -> Right이므로 A13이 된다.
        - 1은 B2E이므로 AB2E3이 된다.
        - 2는 DHI이므로 ABDHIE3 된다.
        - 3은 CFG이므로 ABDHIECFG가 된다.
    
    - Inorder 운행법의 방문 순서
        - Inorder는 Left -> Root -> Right이므로 A13이 된다.
        - 1은 2BE이므로 2BEA3이 된다.
        - 2는 DHI이므로 DHIBEA3 된다.
        - 3은 FCG이므로 DHIBEAFCG 된다.
    
    - Postorder 방문 순서
        - Postorder는 Left -> Right -> Root이므로 A13이 된다.
        - 1은 2EB이므로 2EB3A이 된다.
        - 2는 HID이므로 HIDEB3A 된다.
        - 3은 FGC이므로 HIDEBFGCA 된다.

3. 수식의 표기법(Infix -> Postfix)

    - Infix로 표기된 수식에서 연산자를 해당 피연산자 두 개의 뒤(오른쪽)에 오도록 이동하면 Postfix가 된다.
  
    - X = A / B * (C + D) + E -> X A B / CD + * E + =

4. 수식의 표기법(Infix -> Prefix)

    - Infix로 표기된 수식에서 연산자를 해당 피연산자 두 개의 앞(왼쪽)에 오도록 이동하면 Prefix가 된다.
  
    - X = A / B * (C + D) + E -> X + * / A B + C D E

5. 수식의 표기법(Postfix -> Infix)

    - Postfix는 Infix 표기법에서 연산자를 해당 피연산자 2개의 뒤(오른쪽)로 이동한 것이므로 연산자를 다시 해당 피연산자 2개의 가운데로 옮기면 된다.
  
    - X = A / B * (C + D) + E -> A / (B - C) + D * (E + F)

### 076 정렬(Sort)

1. 삽입 정렬(Insertion Sort)

    예) 8, 5, 6, 2, 4 를 삽입 정렬하시오.

    - 초기 상태 : 8 5 6 2 4
  
    - 1회전 : 8 5 6 2 4 -> 5 8 6 2 4
  
    - 2회전 : 5 8 6 2 4 -> 5 6 8 2 4
  
    - 3회전 : 5 6 8 2 4 -> 2 5 6 8 4
  
    - 4회전 : 2 5 6 8 4 -> 2 4 5 6 8

2. 선택 정렬(Selection Sort)

    n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬한다.

    예) 8, 5, 6, 2, 4 를 선택 정렬하시오.

    - 초기 상태 : 8 5 6 2 4
  
    - 1회전 : 5 8 6 2 4 -> 5 8 6 2 4 -> 2 8 6 5 4 -> 2 8 6 5 4
  
    - 2회전 : 2 6 8 5 4 -> 2 5 8 6 4 -> 2 4 8 6 5
  
    - 3회전 : 2 4 6 8 5 -> 2 4 5 8 6
  
    - 4회전 : 2 4 5 6 8


3. 버블 정렬(Bubble Sort)

    주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환한다.

    예) 8, 5, 6, 2, 4 를 선택 정렬하시오.

    - 초기 상태 : 8 5 6 2 4
  
    - 1회전 : 5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 -> 5 6 2 4 8
  
    - 2회전 : 5 6 2 4 8 -> 5 2 6 4 8 -> 5 2 4 6 8
  
    - 3회전 : 2 5 4 6 8 -> 2 4 5 6 8
  
    - 4회전 : 2 4 5 6 8
  
### 077 검색-이분 분색 / 해싱

1. 이분 검색(이진 검색)

    - 반드시 순서화(정렬)된 파일이어야 검색할 수 있다.
    
    - 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.
  
    - 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
  
    - 중간 레코드 번호(M) : F + L / 2
        > 단, F : 첫번째 레코드 번호, L : 마지막 레코드 번호)

2. 해시 테이블(Hash Table)

    - Collision(충돌 현상) : 서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상
  
    - Synonym : 충돌로 인해 같은 Home Address를 갖는 레코드들의 집합

3. 주요 해싱 함수

    - 제산법(Division) : 레코드 키(K)를 해시펴(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈 나머지를 홈 주소로 삼는 방식
  
    - 제곱법(Mid-Square) : 레코드 키 값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
  
    - 숫자 분석법(Digit Analysis) : 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식 

### 078 데이터베이스 개요

1. DBMS의 필수 기능

    - 정의 기능(Definition) : 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 주고에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
  
    - 조작 기능(Manipulation) : 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
  
    - 제어 기능(Control) : 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어하는 기능

2. 스키마(Schema)

    - 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 기술(Description)한 메타 데이터(Meta-Data)의 집합이다.
  
    - 외부 스키마 : 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
  
    - 개념 스키마 : 데이터베이스의 전체적인 논리적 구조로서, 개체 간의 관계와 제약 조건을 나타내고, 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의함
  
    - 내부 스키마 : 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄 

### 079 데이터베이스 설계

1. 데이터베이스 설계 순서

2. 개념적 설계(정보, 모델링, 개념화)

3. 논리적 설계

### 080


### 081


### 082


### 083


### 084


### 085


#33 086


### 087


### 088


### 089


### 090


### 091
