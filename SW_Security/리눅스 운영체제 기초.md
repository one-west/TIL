# 리눅스 운영체제 기초

> Kisa 아카데미 [정보보호제품군 실습훈련 (기초)] 수강 후 내용 정리

## 목록

- [리눅스 운영체제 개요](#리눅스-운영체제-개요)
- [Linux 기본 명령어](#Linux-기본-명령어)
- [Vi Editor](#Vi-Editor)
- [사용자계정, 그룹, 패스워드, 권한](#사용자계정-그룹-패스워드-권한)
- [프로세스, 데몬, 스케쥴러 이론 및 실습](#프로세스-데몬-스케쥴러-이론-및-실습)

## 리눅스 운영체제 개요

### 리눅스란?

- 소프트웨어 엔지니어 리누스 토발즈가 개발한 운영체제
- Unix와 유사한 프레임으로 공개(Open) 운영체제로, 리눅스 커널 사용
- 무료 및 오픈 소스 소프트웨어로 제공 => 사용자들이 자유롭게 코드를 수정하거나 배포할 수 있음
- 가정용 PC, 서버, 모바일 기기, 임베디드 시스템 등 다양한 플랫폼에서 사용
- 사용자와 시스템이 쉡(Shell)을 통해 상호작용

#### 특징
- 독립된 플랫폼 : CPU 종류에 구애받지 않는 호환성 높은 구동성
- 무료 오픈소스 운영체제
- 다중 사용자 환경 지원
- 기업 / 개인이 자신만의 운영체제로 완성시켜 배포 / 판매 가능

### 리눅스 운영체제 구성 요소

- 커널(Kernel)

    - 운영체제의 핵심으로 메모리에 상주하며 시스템 관리
    - 모든 하드웨어 자원 관리(프로세스, 메모리, 입출력, 파일 관리 등)

- 쉘(Shell)

    - 사용자는 쉘을 통해 명령어 입력
    - 사용자가 입력한 명령어를 해석하여 커널에 전달
    - Bash Shell, C Shell, Korn Shell 등
    - 리눅스의 표준 쉘은 bash Shell

- 파일 시스템(File System)

    - 파일 저장의 기본적인 구조, 시스템을 관리하기 위한 기본 환경 제공
    - 계층적인 트리 구조 형태
 
### 리눅스의 특징

- 여러 사용자가 동시에 동일한 시스템에 접근이 가능한 다중 사용자 기능 지원
- 여러 개의 Task를 동시에 실행하고, 교대로 시스템의 자원을 사용할 수 있는 다중 작업 기능 지원
- 하나의 프로세스 내에서 여러 개의 네트워크 작업을 동시에 처리할 수 있는 다중 스레드 기능 지원
- ext2, ext3, ext4, FAT, FAT32, NTFS, SMB, CIFS, NFS 등의 다양한 종류의 파일 시스템을 지원
- /(root)를 기준으로 하위 디렉터리들이 존재하는 계층적 파일 구조

<img src="https://blog.kakaocdn.net/dn/WRrYP/btrlOWYtekx/UHBRuBwZSwQ96I06kpkwNk/img.png" width="700">

### 유닉스와의 호환성

- 리눅스는 유닉스 운영체제의 영향을 받아 개발 => 기본적으로 유닉스와의 호환성이 높음
- 유닉스 시스템에서 개발된 프로그램들이 대부분 리눅스에서도 동작
- 리눅스는 유닉스와 유사한 명령어와 쉘 사용 => 유닉스에 대한 지식 활용 가능(vi에디터, grep, awk 등)

### 대표적인 리눅스 운영체제

1. Ubuntu : 가장 널리 사용 / GUI환경 지원 / 안정성
2. Rocky Linux : 기존 무료 CentOS => Rocky Linux로 변경
3. Kali : 해킹 및 보안 분야에서 많이 사용되는 리눅스 / 해킹 시뮬, 보안 테스트, 디지털 포렌식
4. Fedora : Red Hot 계열 리눅스

### 리눅스 장점

1. 유닉스와 높은 호환성
2. 공개형 오픈 소스 운영체제
3. 다중 사용자 환경
4. 멀티태스킹과 가상 터미널 환경 지원
5. 유연성과 확장성
6. 안정성과 보안성
7. 다양한 배포판 존재
8. 다양한 응용 프로그램 제공

### 리눅스 단점

1. 문제 발생 시 기술 지원 한계
2. 한글 지원 미흡
3. 이식성, 확장성 등이 뛰어나지만, 특정한 하드웨어에 대한 설치가 어려움
4. 주요 설정에 대해 명령어를 입력하거나 환경설정 파일을 편집해야함(사용자 숙련 필요)

## Linux 기본 명령어

<img src="https://yozm.wishket.com/media/news/2103/1.png">

- ls 명령어 옵션

    |옵션|설명|
    |--|--|
    |-a|숨김 파이을 포함하여 모든 파일과 디렉토리 출력|
    |-t|파일과 디렉토리가 마지막으로 수정된 시간 순으로 출력|
    |-l|상세 정보를 포함하여 파일과 디렉토리 출력|
    |-r|파일 및 디렉토리의 순서를 역순으로 출력|
    |-S|파일과 디렉토리의 크기순으로 출력|
    |-F|파일의 형식을 표시해 출력|

### 시스템 조작

- sudo : 일시적으로 root(superuser) 권한을 얻어 관리자 권한으로 명령을 실행
- su : 사용자 계정을 변경하거나 root(superuser) 계정으로 변경
- apt-get : 패키지 관리자를 이용하여 소프트웨어 설치 및 업데이트 (Debian, Ubuntu 관련 배포반에서 사용)
- yum : 패키지 관리자를 이용하여 소프트웨어 설치 및 업데이트 (RedHat 계열 (CentOS, Fedora)에서 사용)
- systemctl : 시스템 서비스 제어 (시작, 중지, 재시작 등)
    - systemctl [명령] [서비스명]  
    
        |옵션|설명|
        |--|--|
        |start|서비스 시작|
        |stop|서비스 중지|
        |status|서비스 상태 확인|
        |restart|서비스 재시작|
        |reload|서비스 중지하지 않고 설정 값 반영|
        |enable|시스템 재부팅 시 자동으로 서비스 실행하도록 등록|
        |disable|enable한 서비스 해제|

### 파일 관리

- mkdir : 새로운 디렉토리 생성

    |옵션|설명|
    |--|--|
    |-p|하위 디렉토리 모두 생성|
    |-m|디렉토리 권한 설정|
    |-v|디렉토리 생성 후, 실행 결과 출력|

- rm : 파일이나 디렉토리 삭제

    |옵션|설명|
    |--|--|
    |-f|강제로 파일이나 디렉토리 삭제|
    |-r|디렉토리 내부의 모든 내용 삭제|
    |-d|비어 있는 디렉토리들만 삭제|
    |-i|삭제하기 전 확인 메시지 출력|
    |-v|삭제되는 대상의 정보 출력|

## Vi Editor

### Vi Editor란?

- 리눅스와 유닉스 운영체제에서 기본적으로 제공되는 텍스트 편집기
- 입력모드, 명령모드, 마지막 행 모드로 구성
- 파일을 편집하기 위해서는 이 세가지 모드 사용

### Vi Editor 시작 종료

- 실행 : # vi [파일명]

- 종료

    |모드|명령어|설명|
    |--|--|--|
    |마지막행모드|:q|vi에서 작업한 것이 없을 때 vi 편집기 종료|
    ||:q!|작업한 내용을 저장하지 않고 vi 편집기 종료|
    ||:w [파일명]|작업한 내용 저장 vi 편집기 종료 X|
    ||:wq  :wq!|작업한 내용 저장 후 vi 편집기 종료|
    |명령 모드|ZZ|작업한 내용 저장하고 vi 편집기 종료|

### 파일 만들기 & 편집

- 파일 생성 : # vi [파일명]

- 편집하기

    |명령어|설명|
    |--|--|
    |i|현재 커서 앞에 입력|
    |a|현재 커서 뒤에 입력|
    |o|커서가 위치한 행의 다음 행에 입력|

### 명령모드 & 입력모드

- 명령모드

    - vi 편집기를 실행하면 기본적으로 명령모드로 시작
    - 파일 편집을 위한 다양한 명령어 사용 가능
    - 커서 이동, 검색, 삭제, 복사, 붙여넣기, 저장 등의 작업 수행
 
- 입력모드

    - 명령모드에서 i, a, o 등의 명령을 입력하면 입력보드로 전환
    - 현재 커서 위치를 기준으로 앞, 뒤, 다음 행에 입력 가능
 
### 명령모드 & 입력 모드 전환 명령어

- 명령모드 -> 입력모드

    |명령어|설명|
    |--|--|
    |i|현재 커서 위치에서 입력 모드로 전환|
    |a|현재 커서 위치 다음 위치에서 입력 모드로 전화|
    |o|현재 커서가 위치한 라인의 다음 라인에서 입력 모드로 전환|
    |I|현재 커서가 위치한 라인의 첫 번째 위치에서 입력 모드로 전환|
    |A|현재 커서가 위치한 라인의 마지막 위치에서 입력 모드로 전환|
    |O|현재 커서가 위치한 라인의 이전 라인 마지막 위치에서 입력 모드로 전환|

- 입력모드 -> 명령모드 : ESC

## 사용자계정, 그룹, 패스워드, 권한

### 사용자 계정

- root 계정 : 시스템에 대한 모든 권한을 가진 사용자

- 시스템 계정 : 리눅스 설치 시 기본으로 생성되는 계정

- 사용자 계정 : 실제 시스템을 이용하는 일반 사용자 계정으로, 접근과 설정 변경에 제한이 있음

    - 사용자 계정 생성 : useradd [옵션] [사용자명], adduser [옵션] [사용자명]
    - 사용자 계정 삭제 : userdel [옵션] [사용자명]

### 그룹

- 그룹 생성 : groupadd [옵션] [그룹명] , addgroup [옵션] [그룹명]
- 그룹 삭제 : groupdel [그룹명]

### 패스워드

- 패스워드 생성 : passwd [옵션] [사용자명]

### 권한

#### umask
- 새로운 파일이나 디렉토리를 생성할 때 파일의 권한을 설정하는 명령어
- umask 명령어를 통해 mask 값을 설정하여 파일 및 디렉토리의 권한 설정
- 마스크 값 확인 # umask
- 마스크 값 변경 # umask [마스크 값]

- 파일에 대한 마스크 값이 002일 경우 이는 -------w- 으로, 다른 사용자에게 쓰기 권한은 부여하지 않겠다는 뜻

#### 마스크 값의 의미
- 파일 권한을 조정하는 데 사용되는 값
- 파일이나 디렉토리 생성 시 부여하지 않을 권한을 지정해 놓는 것
- 파일에 대한 기본 생성 권한 : 666
- 디렉토리에 대한 기본 생성 권한 : 777
- 기본 생성 권한은 앞에서부터 3자리씩 소유자(User), 그룹(Group), 다른 사용자(Other)로 구분

<img src="https://sp-ao.shortpixel.ai/client/to_auto,q_glossy,ret_img,w_457,h_259/https://nscworld.net/wp-content/uploads/2022/01/image.png">

- 파일 또는 디렉토리 기본 생성 권한 - 마스크 값 = 기본 생성 권한
- 파일에 대한 마스크 값이 002일 경우 이는 666 - 002 = 664 또는 -------w-으로, 다른 사용자에게 쓰기 권한은 부여하지 않겠다는 뜻

#### SetUID

- SetUID가 설정된 파일이 실행되는 동안에는 실행한 사용자의 권한이 아니라, 파일 소유자의 권한으로 실행
- SetUID 설정 방법 : 파일 접근 권한에서 맨 앞자리를 4로 설정
- SetUID가 설정되면 소유자의 실행 권한에 'S' 표시 생성

#### SetGID
- SetGID가 설정된 파일이 실행되는 동안에는 실행한 사용자 그룹의 권한이 아니라, 파일 그룹의 권한으로 실행
- SetGID 설정 방법 : 파일 접근 권한에서 맨 앞자리를 2로 설정
- SetGID가 설정되면 그룹의 실행 권한에 's' 표시 생성
- 디렉토리에 SetGID를 지정하면 하나의 디렉토리에서 여러 사용자의 공동 작업 편리

#### chmod

- 파일 또는 디렉토리의 접근 권한 변경
- chmod [옵션] [권한 모드] [파일명 또는 디렉토리명]
- 옵션 -R : 하위 디렉토리까지 모두 변경

#### chown

- 파일 또는 디렉토리의 사용자와 그룹을 변경 => 파일의 소유권을 변경
- chwon [옵션] [사용자명 또는 그룹명] [파일명 또는 디렉토리명]
- 옵션 -R : 하위 디렉토리까지 모두 변경
- 예시) sudo chown user01 a.out => chown 명령으로 a.out 파일의 사용자(소유자)를 user01로 변경

## 프로세스, 데몬, 스케쥴러 이론 및 실습

### 리눅스 프로세스 동작 원리

- 리눅스에서는 여러 프로세스를 동작시키기 위해 프로세스 스케줄러를 이용
- 리눅스 프로세스는 cpu를 점유하며 실행 상태와 실행 대기 상태로 계속 변경
- 프로세스는 크게 부모 프로세스와 자식 프로세스로 구분
- init 프로세스 : 최초 프로세스로, 리눅스 시스템이 부팅될 때 가장 먼저 실행되어 시스템 서비스를 순서대로 시작시킴
- init 프로세스 PID = 1

### PID란?

- 운영체제에서 프로세스를 식별하기 위해 프로세스에 부여하는 고유 번호
- 각 프로세스마다 고유 번호인 프로세스 ID(PID)를 할당
- PID는 최근 할당된 PID에 1을 더하는 방식으로 ID 할당
- PPID는 부모 프로세스의 PID를 위미
- "ps" 명령을 이용하여 PID 및 PPID, 자식 프로세스 목록 확인 가능

### 리눅스 프로세스 스케줄러란?

- 리눅스 커널의 서브 시스템으로, 프로세스를 작동시키는 역할 수행
- 여러 프로세스 중 프로세스 CPU에서 실행될 프로세스를 선택
- CPU 시간 관리 및 다중 프로세스를 처리하면서 CPU를 최대한 활용하여 시스템의 성능을 최적화

    <img src="https://www.devkuma.com/docs/linux-kernel/mutil-process-thread.png">

### 스케줄링 정책 설정

- SCHED_OTHERS

    - 일반적인 사용자 프로세스에 적용되는 스케줄링 정책
    - 동적 우선순위를 사용하여 타임 슬라이스와 커널에 의해 지속적으로 변경
    
- SCHED_FIFO

    - FIFO : first in first out
    - 긴급한 실시간 프로세스에 적용되는 스케줄링 정책
    - 모든 SCHED_OTHERS 그룹보다 높은 고정 우선순위를 가짐
    - 타입 슬라이스 개념이 존재하지 않기 때문에 해당 프로세스가 가장 높은 우선순위를 가지고 있을 경우, 입출력 요구 등에 의해 스스로 CPU를 반환하기 이전까지 CPU를 계속 사용할 수 있음
 
- SCHED_FIFO

    - 실시간 프로세스에 사용되는 정책
    - 모든 SCHED_OTHERS 그룹보다 높은 고정 우선순위를 가짐
    - 타임 슬라이스 적용
    - 같은 우선 순위 등급을 가질 경우, 타임 슬라이스에 의한 라운드-로빈(Round-Robin) 스케줄링 기법 적용
    - 타임 슬라이스가 다 소진되었을 경우, 스케줄링 큐의 맨 마지막으로 삽입됨으로써 같은 우선순위의 다른 모든 프로세스의 스케줄링 이후에 CPU를 받게 하는 스케줄링

### 스케줄링 클래스

- 리눅스 커널에서는 기본적으로 5개의 스케줄러를 제공

    - Stop 스케줄러, Deadlin 스케줄러, RT 스케줄러, CFS 스케줄러, IDEL 스케줄러
    - 스케줄러 세부 동작을 모듈화함으로써 5개의 스케줄러를 프로세스가 유연하게 사용
    - 5개의 스케줄러를 스케줄러 클래스로 정의
  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEWwW0%2Fbtqyg9KkGaN%2FdBvf821IjxQcM3KfLVBO2k%2Fimg.png" width="800">

### at 스케줄링
- at

    - 정해진 시간에 한 번만 실행
    - 실행할 명령은 표준 입력 장치를 통해 입력
    - 표준 입력 장치에서 명령을 순차적으로 입력 후 [Ctrl + d]를 눌러 작업 예약 완료

- 문법 : # at [-옵션] [시간]

- 옵션

    - I : 현재 예약된 스케줄 목록 출력
    - d [작업번호] : 예약되어 있는 작업 삭제
    - f [파일명] : 스크립트 파일 등 파일을 예약 작업으로 등록

- 예시
    - \# at 21:30 2019-12-25 : 2019년 12월 25일 21시 30분에 명령 실행
    - \# at now+5 minutes : 현재 시간 5분 뒤에 명령 실행
 
### cron 스케줄링

- cron

    - 정해진 날짜, 시간, 요일에 맞워 주기적으로 실행
    - 분, 시, 일, 월 요일, 사용자, 명령으로 총 7개의 필드로 구성

- 문법 : # crontab [-옵션] [파일명]

    <img src="https://blog.kakaocdn.net/dn/xENv5/btqC21vuw1X/vKNLrzEzYQrkgixaz9zsZK/img.png" width="800">


### 데몬이란?

- 리눅스 시스템의 백그라운드에서 실행되는 프로세스
- 특정 요청에 대한 응답을 즉시 수행할 수 있도록 메모리에 상주하며 대기
- 보통 'd'로 끝나는 프로세스들이 데몬을 의미
- PPID 가 1이며, SID 역시 자신의 아이디와 동일
- httpd, ntsd, sshd, Ipd, systemd, ftpd, syslogd 등

### Standalone type daemon

- 독자적으로 구동되는 방식
- 메모리 상에서 항상 대기
- 요청에 대한 응답 속도가 빠름
- 메모리에 부하를 줄 가능성 존재
- 요청이 빈번하게 일어나는 프로세스에서 주로 사용

### Xinetd type daemon

- 메모리 상에서 항상 대기 X
- 슈퍼 데몬이라고 불림
- 부팅할 때 /etc/inetd.conf 이라는 설정 파일을 읽어 들임
- Standlone type daemon 보다 응답 속도가 느림
