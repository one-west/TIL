# JavaScript의 기본문법

## 목차
1. [[코드 작성 규칙]](#코드-작성-규칙)
2. [[자료형]](#자료형)
3. [[변수]](#변수)
4. [[조건문]](#조건문)
5. [[반복문]](#반복문)
6. [[객체]](#객체)
7. [[클래스]](#클래스)

## 코드 작성 규칙

- 세미콜론(;)
  - 붙여도 되고 붙이지 않아도 됨
  - 붙이가를 권장
  - 한 줄에 여러 명령을 넣을 때는 세미콜론으로 구분

    ```js
    console.log('Hello, world!'); console.log('Hello, JavaScript!');
    ```

- 주석
  - 사람만 알아볼 수 있도록 설명을 작성한 부분
  - 코드에 영향을 미치지 않음
  - 한 줄 주석 : // 기호 뒤에 작성

    ```js
    console.log('Hello, comment!'); // Hello, comment! 출력
    ```

  - 여러 줄 주석 : /* */ 기호로 감싼, 안쪽에 작성

    ```js
    /* console.log('Hello, world!');
    console.log('Hello, comment!'); */
    ```

- 들여쓰기
  - 제한 없음
  - 규칙적으로 사용하면 코드의 가독성을 높일 수 있음

    ```js
    if (condition) {
      console.log('Hello, world!');
    }
    ```

## 자료형

값(value) : 프로그램에서 조작할 수 있는 데이터
자료형(data type) : 값의 종류
- 문자열
  - 문자열(String) : 문자들이 하나 이상 나열되어 있는 자료형
  - 시작과 끝이 따옴표로 감싸진 값
  - 시작과 끝을 같은 종류의 따옴표로 감싸야 함
  - 연산자(operator) : 어떠한 값에 특정 작업을 수행하라는 의미를 나타내는 기호
  - 문자열 안에 따옴표 사용하기
    - 따옴표가 문자열 중간에 들어 있을 때
    - 문자열을 다른 종류의 따옴표로 감싸야 함

      ```js
      ↓                               ↓   ↓                     ↓
      '문자열 안에 작은따옴표(')가 있음~';  '문자열 안에 작은따옴표('가 있음~';
      // 사람이 인식하는 문자열의 시작과 끝  // 자바스크립트 엔진이 인식하는 문자열의 시작과 끝
      ```

      - 이스케이핑(escaping): 기호를 다르게 해석하게 하는 행위
      - 예): 백슬래시(\)가 붙은 따옴표는 일반 문자로 해석

        ```js
        > "문자열 안에 큰따옴표가(\")가 있어요~";
        < '문자열 안에 큰따옴표가(")가 있어요~';
        > '문자열 안에 작은따옴표가(\')가 있어요~';
        < "문자열 안에 작은따옴표가(\')가 있어요~";
        ```

  - 한 문자열을 여러 줄로 표시하기
    - 문자열에서 줄바꿈할 부분 앞에 \n문자 넣기  

      ```js
      alert('줄바꿈을 해주는 \n표시입니다.');
      ```

  - 템플릿 리터털 사용하기
    - 템플릿 리터럴(template literal): 백틱(`, backtick 또는 backquote)으로 감싸진 문자열
    - 백틱 문자열을 사용하면 \n문자를 사용하지 않아도 줄바꿈을 할 수 있음

      ```js
      alert(`여러 줄에 걸쳐
      표시됩니다.
     
      줄을 더 늘려 볼까요?`);
      ```

  - 문자열 합치기
    - 두 문자열 사이에 + 기호를 두면 양쪽 문자열이 하나로 합쳐짐

      ```js
      > '문자열이 긴 경우에는 문자열을 ' + '나눈 뒤 다시 합칩니다.';
      < '문자열이 긴 경우에는 문자열을 나눈 뒤 다시 합칩니다.'
      ```

- 숫자
  - 숫자(number): 따옴표 없이 숫자 그대로 작성
  - 따옴표로 감쌀 경우 문자열이 됨
  - 지수 표기법(Exponential notaion)을 사용할 수 있음

    ```js
    5e4; // 5 * 10**4(10000) = 50000 (+는 생략 가능)
    5e+4; // 5 * 10**4(10000) = 50000
    5e-3; // 5 * 10**(-3)
    ```

  - 문자열을 숫자로 바꾸기
    - parseInt()와 Number() 사용
    - parseInt() 함수: 문자열을 정수로만 바꿈
    - 문자열을 실수로 바꾸고 싶으면 parseFloat() 함수 또는 Number() 함수 사용

  - NaN
    - NaN: Not a Number
    - 주의: 이름과는 다르게 숫자판정

  - 산술 연산자 사용하기
    - +, -, *, / 등의 기호를 사용
    - % 연산자: 나눗셈의 나머지를 구하기
    - **연산자: 숫자를 거듭제곱

  - 무한 값
    - Infinity: 무한 값
    - -Infinity: 음수 무한 값, 음수를 0으로 나누는 경우
    - NaN: 무한끼리 연산할 때(연산이 성립하지 않는다는 의미)

  - 문자와 숫자 더하기
    - 형 변환(type casting): 값의 자료형이 바뀌는 현상 또는 바꾸는 행위
    - +연산자를 사용할 때는 숫자보다 문자열이 우선시
    - 예: 문자열 '1'과 숫자 0을 더하면 숫자 1이 아니라 문자열 '10'이 나옴
    - -연산자를 사용할 때는 다른 자료형이 먼저 숫자로 형 변환된 후 연산
    - 예: 문자열 '9'는 숫자 9로 형 변환되고, 여기서 5를 빼기 때문에 숫자 4가 나옴

  - 연산자 우선순위 이해하기
    - 연산자 우선순위가 높을수록 먼저 계산
    - 같은 우선순위의 연산자가 여러 개 나오면 먼저 나온 순서대로 계산
      ![연산자 우선순위](https://velog.velcdn.com/images%2Fsdtana%2Fpost%2F974f8de3-103d-4f26-bbe8-92e9bc09aa9c%2Fimage.png)

  - 실수 연산 시 주의할 점
    - 부동소수점 문제: 10진법으로 계산한 결과와 차이가 발생
    - 원인: 2진법으로 실수를 표현하면 무한 반복되는 실수가 있어서 어쩔 수 없이 근삿값으로 저장
    - 해결 방법: 실수를 정수로 바꿔 계산하고 마지막에 다시 실수로 바꾸기

- 불 값
  - 불 값(boolean): 참(true)과 거짓(false)을 나타내는 자료형
  - 불 값 표현하기
    - 따옴표로 감싸지 않고 true와 false를 입력

  - 비겨 연산자 사용하기
    - \>: 왼쪽 값이 오른쪽 값보다 크다(초과)
    - <: 왼쪽 값이 오른쪽 값보다 작다(미만)
    - \>=: 크거나 같다(이상)
    - <=: 작거나 같다(이하)
    - ==: 양쪽 값이 같은지 비교
    - !=: 양쪽 값이 다른지 비교

  - ==와 ===의 다른 점
    - ==: 값이 같은지 비교. 자료형이 달라도 값이 같으면 true
    - ===: 값뿐 아니라 자료형까지 같은지 비교. 자료형까지 같을 때만 true  
      > 이건 사실 자세하게 파면 메모리 영역까지 가야함...
  - 논리 연산자 사용하기
    - && 연산자: '그리고'를 의미 (왼쪽 식과 오른쪽 식 모두 true면 true)
    - || 연산자: '또는'을 의미 (왼쪽 식이나 오른쪽 식 둘 중 하나라고 true면 true)

  - 논리 연산자 사용 시 유의할 점
    - && 연산자: 앞에 오는 값이 true면 뒤에 오는 값 결과, 앞에 오는 값이 false면 앞에 오는 값이 결과
    - || 연산자: 앞에 오는 값이 true면 앞에 오는 값 결과, 앞에 오는 값이 false면 뒤에 오는 값이 결과
    - ?? 연산자(널 병합 연산자, nullish coalescing operator): 앞에 오는 값이 null이나 undefined면 뒤에 오는 값이 결과, null, undefined도 아니면 앞에 오는 값이 결과

- 빈 값 사용하기
  - undefined
    - 빈 값 (비어 있음을 의미)
    - 값이자 자료형
    - 보통 반환할 결과 값이 없을 때 기본 값으로 사용

- null
  - 빈 값
  - undefined와 같지 않음

## 변수

- 변수(variable): 값을 저장하고 저장한 값을 불러올 수 있게 하는 것
- 변수 선언(declaration): 변수를 만드는 행위

### let으로 변수 선언하기

- 변수를 선언하는 방법
  - let(또는 const, var) 다음에 선언하려는 변수명(변수의 이름) 적고 뒤에 대입(assignment, 할당)연산자 = 입력,  
    = 연산자 뒤에는 변수에 저장할 식 입력  
    `let 변수명 = 식;`
    
- 선언문: let으로 시작하는 명령
- 초기화(initialization): 변수를 선언함과 동시에 값을 대입하는 행위

  ```js
  let total = 5000;    let string = 'Hello, variable';
  ```

### 변수명 짓기

- 변수명: 변수의 값이 무엇인지 알려 주는 역할을 하므로 자세하게 짓기
- 변수명의 제약 사항
  - 특수문자는 $와 _만 사용할 수 있다.
  - 숫자로 시작해서는 안 된다.
  - 예약어(reserved word)는 변수명으로 사용할 수 없다.
  - 위의 제약 사항을 어기지 않는다면 한글, 한자, 유니코드도 가능

### 변수의 값 수정하기

- 변수에 넣은 값을 바꿀 때: 대입 연산자를 사용해 새로운 값 입력

  ```js
  let change = 'change'
  change = 'ok'
  ```

- 변수에 넣은 값을 비울 때: undefined를 대입하거나 null을 대입

### 변수 활용하기

- 변수는 계산된 값을 저장할 때
- 코드 중복을 줄일 때

### const로 상수 선언하기

- const: 상수(constant)의 줄임말
- 한번 값을 대입하면 다른 값을 대입할 수 없다는 특성 때문에 상수 선언 시 초기화(선언과 동시에 값을 대입하는 것)하지 않으면 에러 발생

  ```js
  const value = '나는 상수'
  undefined
  value = '나는 변수?'
  Uncaught TypeError: Assignment to constant variable.
  ```

### var 알아두기

- var: 변수(variable)의 줄임말
- 변수문(variable): var로 변수를 선언한 문장
- 기존에 선언한 변수를 다시 선언해도 에러가 발생하지 않음
- 예약어에 사용하는 단어를 변수명으로 사용할 수 있음
- var 대신 let을 사용하면 에러가 발생해 해당 이름을 변수명으로 사용하지 못하게 막음

## 조건문

- 조건문: 주어진 조선에 따라 코드를 실행하거나 실행하지 않는 문

### 조건문의 기본 형식

- 조건문을 나타내는 예약어인 if 뒤에 나오는 소괄호 안에 조건(식)을 넣고, 다음 줄에 실행문을 넣기

  ```js
  if (조건식) {
    실행문
  }
  ```
  
- 조건문은 조건식과 실행문으로 구분
- 조건식이 참인 값이면 실행문이 실행되고, 거짓인 값이면 실행문이 실행되지 않음
- 실행문에는 여러 개의 식을 넣을 수 있음
- 실행문의 식이 둘 이상이면 식들을 중괄호로 감싸기

### else를 사용해 두 방향으로 분기하기

- if문 뒤에 else를 붙이고 실행문 입력
- else문도 실행문에 식을 여러 개 넣을 수 있음
- 식이 하나인 경우 중괄호 생략 가능

### else if를 사용해 여러 방향으로 분기하기

- if문과 else 문 사이에 else if를 적고 그 뒤에 해당하는 조건식과 실행문 추가
- else if문 뒤에 else문은 생략 가능

  ```js
  if (조건식) {
    실행문
  } else if (조건식) {
    실행문
  } else {
    실행문
  }
  ```
  
- else if문 실행문에 식을 여러 개 넣을 수 있음
- 식이 하나인 경우에는 중괄호 생략 가능
- if문과 else문 사이에 else if문을 원하는 만큼 넣을 수 있음
- if문과 else if문만 사용해도 되고, if문과 else문을 사용해도 됨
- else if문이나 else 문은 단독으로 사용할 수 없음

### 중첩 if문 사용하기

- if, else, else if 문 안에 다시 조건문을 넣을 수 있음
- 중첩 if 문을 if-else if-else 문으로 변환해 코드의 가독성을 높이길 권장

### switch문으로 분기하기

```js
switch (조건식) {
  case 비교 조건식:
    실행문
}
```

- switch 문에는 조건식 2개 사용
- switch 옆에 있는 소괄호의 조건식 값이 case의 비교 조건식 값과 일치(===)하면 해당하는 실행문이 실행
- 보통 조건식에 변수를 넣고, 비교 조건식에는 변수와 비교할 값을 넣음
- case를 여러 번 사용해 여러 방향으로 분기
- break 문을 사용해 case 문을 빠져나옴
- default를 사용해 어떤 것도 일치하지 않을 때 실행하는 case 문을 만듦

### 조건부 연산자 사용하기

```js
조건식 ? 참일 때 실행되는 식 : 거짓일 때 실행되는 식
```

- 조건부 연산자 또는 삼항 연산자라고 하는 특수 연산자로 분기 처리 가능
- 조건부 연산자도 중첩해서 사용할 수 있다.

## 반복문

```js
while (조건식) {
  실행문
}
```

- while 문: 조건식이 참일 동안 반복해서 실행문 실행

### for 문으로 반복해서 출력하기

```js
for (시작; 조건식; 종료식) {
  실행문
}
```

- for 문과 while 문의 실행 순서 비교

  ```js
  for (let i = 0; i < 100; i++) {
      console.log('Hello, for!');
  }
  
  let i = 0;
  while (i < 100) {
      console.log('Hello, while!');
      i++;
  } 
  ```
  
- break 문: 반복문을 중간에 멈춰야 할 때 사용
- continue 문: 반복문이 특정 조건에서만 실행되게 할 때 사용

### 중첩 반복문 사용하기

- 중첩 반복문: 반복문 안에 반복문이 들어 있는 경우
- 중첩 반복문의 실행순서  


  <img src="https://dojang.io/pluginfile.php/13649/mod_page/content/2/019002.png" height=300></img>
 
## 객체
- 객체(object): 다양한 값을 모아 둔 또 다른 값

### 배열
- 배열 생성하기
  - 대괄호([], 배열 리터럴)로 값들을 한꺼번에 감싸고, 각 값은 쉼표로 구분
  - 인덱스(index): 값의 자릿수로, 0부터 시작
  - 이차원 배열: 배열 안에 배열이 있는 경우
  - 요소(element): 배열의 값
  - 메모리에서 배열의 구조

- 배열의 요소 개수 구하기
  - 배열 이름 뒤에 .length 붙이기
  - 빈 값도 유효한 값이므로 요소 개수를 셀 때 포함
  - 요소를 찾는 방법: 인덱스 사용하기, at() 사용하기

- 배열에 요소 추가하기
  - 원하는 배열의 인덱스에 값 대입
  - unshift(): 배열의 맨 앞에 새로운 요소를 추가할 때
  - push(): 배열의 맨 뒤에 값을 추가할 때

- 배열의 요소 수정하기
  - 원하는 인덱스에 바꿀 값 넣기

- 배열에서 요소 삭제하기
  - pop(): 마지막 요소를 삭제할 때
  - shift(): 첫번째 요소를 삭제할 때
  - splice(): 중간 요소를 삭제할 때
  - splice(시작 인덱스, 삭제할 요소 개수)로 작성하며, 숫자를 하나만 넣으면 배열 끝까지 삭제

- 배열에서 요소 찾기
  - includes(): 주어진 값이 배열에 존재하는지 확인할 때 사용, 있으면 true, 없으면 false
  - indexOf(): 검색하려는 값이 어느 인덱스에 위치하는지 앞에서부터 찾을 때
  - lastIndexOf(): 검색하려는 값이 어느 인덱스에 위치하는지 뒤에서부터 찾을 때
  - indexOf()와 lastIndexOf() 사용 시 주의할 점: 값 뿐 아니라 자료형도 일치해야 함

- 배열 자르고 합치기
  - slice(): 시작 인덱스부터 종료 인덱스까지 배열을 잘라 새 배열 만들기

    ```js
      배열.slice(<시작 인덱스>, <종료 인덱스>)
    ```
    
  - concat(): 두 배열을 합쳐 하나의 새로운 배열로 만들기

    ```js
      배열.concat(배열1, 배열2, ...)
    ```

- 배열과 비슷한 문자열의 특징
  - 문자열은 문자를 여러 개 이어 놓은 것이라서 이를 각각 분리할 수도 있음
  - 배열과 마찬가지로 0부터 시작
  - 문자열 길이 구하기: 문자열 뒤에 .length
  - indexOf(), includes(), lastIndexOf() 도 사용할 수 있다.

- join(): 배열을 문자열로 만들 때
  - 소괄호 안에 아무 값이 없으면 배열의 요소를 쉼표로 합치기
  - 문자열이 있으면 해당 문자열을 요소 사이사이에 넣어 하나의 문자열로 만들기
    
- split(): 문자열을 배열로 만들 때
  - 소괄호 안에 값이 없으면 문자열이 배열의 첫번째 요소가 됨
  - 소괄호에 빈 문자열을 넣으면 대상 문자열이 전부 개별 문자로 쪼개져 각각 배열의 요소가 됨
  - 소괄호 안에 넣은 문자열이 대상 문자열에 있으면 해당 문자열을 기준으로 대상 문자열을 나눔

- 배열 반복하기
  - 배열은 값들을 나열한 것이라 반복문과 함께 사용하는 경우가 많음
  - while 문, for 문 모두 사용 가능

- 이차원 배열
  - 배열의 요소로 배열이 들어 있을 때
  - 이차원 배열의 대표적인 예
    ||    A|
    |---|--|
    |1|   1|
    |2|   2|
    |3|   3|

- flat()과 fill()
  - flat(): 배열의 차원을 한 단계 낮추기
  - fill(): 빈 배열의 요소를 특정 값으로 미리 채우기
   
- Set으로 중복 요소 제거하기
  - Set은 배열과 달리 중복을 허용하지 않음
  - 배열뿐 아니라 문자열 중복도 제거
  - size: Set의 요소 개수를 구할 때
  - Array.from(): Set을 배열로 바꿀 때

### 함수
- 함수(function): 특정한 작업을 수행하는 코드
- 함수 선언하기
  - 함수 선언(declare): 함수를 만드는 행위
  - 익명 함수(anonymous function): 이름이 없는 함수

    ```js
    function () {};
    () => {};
    ```
    
  - 함수 선언문(function declaration statement): 함수를 상수에 대입하지 않고 function 뒤에 함수의 이름을 넣는 방식

    ```js
    function 이름() { 실행문 }
    ```
    
  - 함수 표현식(function expression): 함수를 상수나 변수에 대입하는 방식

    ```js
    이름 = function () { 실행문 }
    ```
    
  - 화살표 함수(arrow function): 화살표 기호를 사용한 함수

    ```js
    () => { 실행문 } // 또는
    () => 반환식
    ```
    
- 함수 호출하기
  - 함수 호출(call): 함수를 사용하는 행위
  - 함수를 선언한 후 함수 이름 뒤에 ()를 붙여 호출하면 함수가 실행됨

- return 문으로 반환값 지정하기
  - 반환값(return value): 함수를 호출하면 나오는 결과 값

- 매개변수와 인수 사용하기
  - 인수(argument): 함수를 호출할 때 넣은 값
  - 매개변수(parameter): 함수를 선언할 때 사용한 변수
  - 매개변수와 인수의 관계

    ```js
    function a(parameter) {  // 함수 선언
      console.log(parameter);
    }
    a('argument');  // 함수 호출
    ```
    
- 순수 함수(pure function): 자신의 매개변수나 내부 변수(또는 상수)만 사용하는 함수
- 고차 함수(high order function): 함수를 만드는 함수

### 객체 리터럴
- 객체 생성하기
  - 속성(property): 중괄호로 묶인 정보. 속성 이름과 속성 값으로 구분
  - 객체 리터럴(object literal): 중괄호를 사용해 객체를 표현하는 것

    ```js
    {
      속성이름: 속성 값,
    }
    ```
    
- 객체 속성에 접근하기
  - 속성 이름을 통해 속성 값을 접근
  - 마침표(.) 사용 시: 변수.속성
  - 대괄호( [] ) 사용 시: 변수['속성']
    
- 객체 속성을 추가/수정/삭제하기
  - 추가: 변수.속성 = 값;
  - 수정: 변수.속성 = 값;
  - 삭제: delete 변수.속성;

- 메서드 이해하기
  - 메서드(method): 객체의 속성 값으로 함수가 들어갔을 때 해당 속성을 메서드라고 함

- 객체 간 비교하기
  - 문자열, 불, null, undefined를 비교하면 모두 true 반환
  - NaN만 false 반환

- 중첩된 객체와 옵셔널 체이닝 연산자
  - 객체 안에도 객체가 들어 갈 수 있음
  - 속성에 접근할 때 마침표와 대괄호를 조합 사용 가능
  - 변수.속성.['속성'], 변수['속성'].속성 형태로도 가능
  - ?. 연산자(옵셔널 체이닝, optional chaining operator): 존재하지 않는 속성에 접근할 때 에러가 발생하는 것을 막아줌

    ```js
    oneWest.girlfriend?.name;
    undefined
    oneWest.name?.first;
    '한서'
    ```
    
- 참조와 복사

  ```js
  const a = { name: 'onewest' } // 변수 a가 객체를 가리킴
  const b = a; // 변수 b가 변수 a를 가리킴
  ```
  
  -> 이럴 때 **변수 a와 b가 같은 객체를 참조하고 있다** 또는 **변수 a와 b 그리고 객체 간에 참조 관계가 있다**고 표현
  - 객체가 아닌 값을 대입한 경우: 참조 관계가 생기지 않는 상황
  - 복사(copy): 어떤 값을 변수에 대입할 때 기존 값과 참조 관계가 끊기는 것
  - 객체가 아닌 값은 애초부터 참조 관계가 없으므로 그냥 복사만 됨
  - 얕은 복사(shallow copy): 외부 객체만 복사되고 내부 객체는 참조 관계를 유지하는 복사
  - 얕은 복사 시...연산자(스프레드 문법, spread syntax) 사용
  - 깊은 복사(deep copy): 내부 객체까지 참조 관계가 끊기면서 복사되는 것

- 구조분해 할당
  - 객체의 속성 이름과 대입하는 변수명이 같을 때 다음과 같이 줄여서 쓸 수 있음

    ```js
    const person = { name: '원웨스트' }
    const name = person.name
    const { name } = person // 앞 줄과 같은 의미
    name; // '원웨스트'
    ```
    
- 유사 배열 객체
  - 배열 모양을 한 객체
  - 배열이 아니므로 배열 메서드를 사용할 수 없음

### 함수를 인수로 받는 배열 메서드
- forEach()와 map()
  - forEach(): for 문을 사용하지 않고도 반복문 수행 가능

    ```js
    배열.forEach(함수);
    ```
    
  - forEach()메서드의 인수

    ```js
    const arr = [1, 5, 4, 2];
    arr.forEach((number, index) => {
      console.log(number, index);
    });
    ```

  - 콜백 함수(callback function): 다른 메서드에 인수로 넣었을 때 실행되는 함수
  - 메서드에 콜백 함수 전달 원리
  - map(): 배열 요소들을 일대일로 짝지어서 다른 값으로 변환해 새로운 배열을 반환

    ```js
    배열.map(콜백 함수);
    ```
    
  - map()메서드의 인수

    ```js
    // [1, 1, 1, 1, 1]
    map((v, i) => i + 1)
    // [1, 2, 3, 4, 5]
    ```
    
- find(), findIndex(), filter()
  - find(): 콜백 함수의 반환값이 true인 요소를 찾는 메서드
  - findIndex(): 찾은 요소의 인덱스를 반환하고, 찾지 못했다면 -1을 반환하는 메서드
  - filter(): 콜백 함수의 반환값이 true가 되는 모든 요소를 찾아 결과를 배열로 반환하는 메서드

    ```js
    배열.find(콜백 함수);
    배열.findIndex(콜백 함수);
    배열.filter(콜백 함수);
    ```

- sort()
  - 비교 함수의 반환값에 따라 배열을 정렬하는 메서드

    ```js
    배열.sort(비교 함수);
    ```
    
  - 비교 함수의 형식

    ```js
    (a, b) => 반환값
    ```

- reduce()
  - 배열의 있는 반복 메서드의 일종
  - 배열의 요소들을 하나의 값으로 합침
  - 초기 값이 없으면 배열의 첫 번째 요소가 초기 값이 됨

    ```js
    배열.reduce(누적 값, 현재 값) => {
      return 새로운 누적 값;
    }, 초기 값);
    ```

- every()와 some()
  - every(): 하나라도 조건을 만족하지 않는 요소(조건 함수가 false를 반환)를 찾으면 반복 중단
  - some(): 하나라도 조건을 만족하는 요소(조건 함수가 true를 반환)를 찾으면 반복 중단

## 클래스
- 클래스(class): 객체를 생성하기 위한 템플릿(서식)

### 함수로 객체를 생성하는 방법
- 공장 함수(factory function): 객체를 반환하는 함수
- 새로운 객체가 필요하면 그때마다 함수 호출

  ```js
  function createMonster(name, hp, att) {
    return { name, hp, att };
  }
  const monster1 = createMonster('슬라임', 25, 10);
  const monster2 = createMonster('슬라임', 26, 9);
  const monster3 = createMonster('슬라임', 25, 11);
  ```

- 생성자 함수(constructor function): new를 붙여 호출하는 함수
- new를 붙여 호출할 때마다 새로운 객체 생성

  ```js
  function Monster(name, hp, att) {
    this.name = name;
    this.hp = hp;
    this.att = att;
  }
  const monster1 = new Monster('슬라임', 25, 10);
  const monster2 = new Monster('슬라임', 26, 9);
  const monster3 = new Monster('슬라임', 25, 11);
  ```

- 프로토타입(prototype): 생성자 함수로 생성한 객체가 공유하는 속성
- 생성자 함수는 prototype 속성 안에 추가해야 메서드를 재사용할 수 있음

  ```js
  function Monster(name, hp, att) {
    this.name = name;
    this.hp = hp;
    this.att = att;
  }
  Monster.prototype.attack = function(monster) {
    monster.hp -= this.att;
  };
  const monster1 = new Monster('슬라임', 25, 10);
  const monster2 = new Monster('슬라임', 26, 9);
  monster1.attack === monster2.attack;
  ```

### this 이해하기
- this: 상황에 따라 값이 달라짐(기본으로 window 객체를 가리킴)
  - 객체 메서드로 this를 사용하면 this는 해당 객체를 가르킴
  - 함수의 this는 bind() 메서드를 사용해 값을 바꿀 수 있음
  - 생성자 함수를 호출할 때 new를 붙이면 this는 생성자 함수가 새로 생성하는 객체가 됨

### 클랙스로 객체를 생성하는 방법
- class 예약어로 클래스 선언
- 생성자 함수 이름을 클래스 이름으로 넣음
- 매개변수를 포함한 기존 함수의 코드는 constructor() 메서드 안에 넣음

  ```js
  class 클래스 이름 {
    constructor (매개변수1, 매개변수2, ...) {
      // 생성자 함수 내용
    }
  }
  ```

### 클래스 상속하기
- 상속: 부모 클래스에서 공통부분을 가져와 사용하는 것
- 부모 클래스: 복수의 클래스에서 공통되는 부분만 추려 만든 클래스
- 자식 클래스: 부모 클래스에서 공통부분을 가져와 사용하는(상속받는) 클래스

  ```js
  class 자식 클래스 extends 부모 클래스 {
    constructor(매개변수1, 매개변수2, ...) {
      super(인수1, 인수2, ...); // 부모 클래스의 생성자 호출
      this.매개변수 = 값; // 자식 클래스만의 속성
    }
  }
  메서드() { // 부모 클래스의 메서드만 호출하면 생략 가능
    super.메서드(); // 부모 클래스의 메서드 호출
    // 부모 클래스 메서드 호출 이후의 동작
  }
  메서드(매개변수1, 매개변수2, ...) {
    // 자식 클래스만의 동작
  }
  ```

### 자료출처
- https://ko.javascript.info/
- https://helloworldjavascript.net/
- https://developer.mozilla.org/ko/docs/Web/JavaScript
